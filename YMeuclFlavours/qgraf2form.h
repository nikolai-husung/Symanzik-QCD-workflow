***** Declaration of vertices, fields etc. *****

** fields
NFunction mediator,anchor,anchor2,src;
NFunction bgf,ghost,aghost,gluon,quark,aquark,quark2,aquark2;
Autodeclare NFunction field;
** graph specifics
NFunction prop,vert;
CFunction ext;


***** Yang-Mills specific constants *****
** Nc = number of colours
** Ng = Nc^2-1 = number of generators of the algebra
** TF = 1/2
**
** CF = TF*(Nc^2-1)/Nc
** CA = Nc
Symbol TF,CF,CA,Nf,Ng,Nc;
** The quark mass M has an additional flavour index
CFunction M,Tr(cyclic),Trtemp;


***** Gauge parameter (yi=xi-1) *****
Symbol yi,xi;


***** Colour indices *****
Autodeclare Index col=Ng;
Autodeclare Index cf=Nc;

** Set counter for colour indices
#define ccnt "20"
#define cfcnt "20"

** Colour tensors
CTensor FC(antisymmetric),DC(symmetric),TC;


***** fermion line indices *****
Autodeclare Index fl=D;

** Set counter for fermion line indices
#define flcnt "20"

** Fermion line tensor
CTensor FL,FLOOP;
Index G5=0;

***** This procedure prepares diagrams generated by QGRAF and eventually applies the Feynman rules. *****
#procedure qgraf2form

** Enforce energy momentum conservation on external momenta
id ext(field?!{anchor,anchor2,src},imp?,fl?) = ext(field,imp,fl)*Pbuffer(imp);
id ext(field?{anchor,anchor2},imp?,fl?) = ext(field,fl)*replace_(imp,ZERO);


*** !!!!! check this line !!!!! also whether PP would choose always the same ext. field!
if(match(ext(src,?args))==0);
   id Pbuffer(impe1) = Test(impe1);
else if(match(ext(src,?args))>1);
   exit, "More than one src field not yet implemented.";
endif;

repeat id Pbuffer(imp1?)*Pbuffer(imp2?) = Pbuffer(imp1+imp2);

if(count(Test,1)>0);
   id Pbuffer(imp1?)*Test(imp2?) = replace_(imp2,-imp1);
else;
   id Pbuffer(imp1?)*ext(src,imp2?,?args) = replace_(imp2,imp1);
endif;

** Handle zero momentum of tadpoles (needed for correct UV-pole extraction!)
id prop(field?,0,?args) = prop(field,ZERO,?args);
argument vert;
   id field?(0,?args) = field(ZERO,?args);
endargument;


*** drop NOW unnecessary external fields
id ext(field?!{aquark,quark,aquark2,quark2},?args) = 1;


#include feynmanRules/`o'.h
if(match(vert(?args,anchor(?args2)))) discard;
argument vert;
   id anchor2(?args) = anchor(?args);
endargument;
#include feynmanRules/`o2'.h

*** Dump all vertices, which do not contribute to operator of interest
if(match(vert(?args1,field?{anchor,anchor2,src}(?args4)))> 0) discard;

*** QCD rules
#include feynmanRules/pureGauge.h
#include feynmanRules/quarks.h


***** reduce fermion lines *****
repeat id FL(fl0?,?args,fl?)*FL(fl?,?args2) = FL(fl0,?args,?args2)*replace_(fl,fl0);
#endprocedure


***** This procedure implements the reduction of the SU(Nc) algebra. *****
#procedure Colours
** Replace FC and DC by appropriate traces
#do dummy=1,1
   id,once FC(col1?,col2?,col3?) = -1/TF*(
      + TC(col1,cf`cfcnt',cf{`cfcnt'+1})*TC(col2,cf{`cfcnt'+1},cf{`cfcnt'+2})
      - TC(col2,cf`cfcnt',cf{`cfcnt'+1})*TC(col1,cf{`cfcnt'+1},cf{`cfcnt'+2}))*TC(col3,cf{`cfcnt'+2},cf`cfcnt');
   redefine cfcnt "{`cfcnt'+3}";
   if(count(FC,1)>0) redefine dummy "0";
   .sort;
#enddo

#do dummy=1,1
   id,once DC(col1?,col2?,col3?) = -1/TF*(
      + TC(col1,cf`cfcnt',cf{`cfcnt'+1})*TC(col2,cf{`cfcnt'+1},cf{`cfcnt'+2})
      + TC(col2,cf`cfcnt',cf{`cfcnt'+1})*TC(col1,cf{`cfcnt'+1},cf{`cfcnt'+2}))*TC(col3,cf{`cfcnt'+2},cf`cfcnt');
   redefine cfcnt "{`cfcnt'+3}";
   if(count(DC,1)>0) redefine dummy "0";
   .sort;
#enddo

** Handle generators carrying identical adjoint indices
repeat;
   id TC(col1?,cf1?,cf2?)*TC(col1?,cf3?,cf4?) = -TF*(d_(cf1,cf4)*d_(cf3,cf2)-1/Nc*d_(cf1,cf2)*d_(cf3,cf4));
endrepeat;

** Rewrite everything as cyclic Tr[aces]
id TC(col?,cf?,cf?) = 0;
id TC(col1?,cf1?,cf2?) = Trtemp(col1,cf1,cf2);
repeat;
   id Trtemp(?args,col1?,cf1?,cf2?)*Trtemp(col2?,?args2,cf2?,cf3?) = Trtemp(?args,col1,col2,?args2,cf1,cf3);
endrepeat;
id Trtemp(?args,cf1?,cf1?) = Tr(?args);
id Tr(col1?) = 0;
id Tr(col1?,col2?) = -d_(col1,col2)*TF;

** Combine traces identical due to cyclicity
.sort;

** handle single generator separately
id Trtemp(col1?,cf1?,cf2?) = TC(col1,cf1,cf2);
#endprocedure
